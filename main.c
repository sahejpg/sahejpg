#include "main.h"

#include <stdio.h>
#include <stdlib.h>

#include "gba.h"
/* TODO: */
// Include any header files for title screen or exit
// screen images generated by nin10kit. Example for the provided garbage
// image:
// #include "images/garbage.h"
#include "img/cat.h"
#include "img/start.h"
#include "img/lose.h"


/* TODO: */
// Add any additional states you need for your app. You are not requried to use
// these specific provided states.
enum gba_state {
  START,
  PLAY,
  END
};

int main(void) {
  /* TODO: */
  // Manipulate REG_DISPCNT here to set Mode 3. //
  REG_DISPCNT = MODE3 | BG2_ENABLE;

  // Save current and previous state of button input.
  u32 previousButtons = BUTTONS;
  u32 currentButtons = BUTTONS;

  // Load initial application state
  enum gba_state state = START;

  struct cat cat1;
  struct cat *new;
  new = &cat1;

  struct goal goal1;
  struct goal *newg;
  newg = &goal1;

  int time = 0;
  int temp;

  while (1) {
    currentButtons = BUTTONS; // Load the current state of the buttons
    if (vBlankCounter % 60 == 0) {
      time++;
    }

    // resets whenever button pressed
    if (KEY_JUST_PRESSED(BUTTON_SELECT,currentButtons,previousButtons)) {
          state = START;
        }

    /* TODO: */
    // Manipulate the state machine below as needed //
    // NOTE: Call waitForVBlank() before you draw

    switch (state) {
      case START:
        cat1.row = 0;
        cat1.col = 0;
        goal1.wid = 5;
        goal1.len = 5;
        goal1.row = rand() % (145 + 1);
        goal1.col = rand() % (235 + 1);
        time = 0;


        // transfer to the game page
        if (KEY_JUST_PRESSED(BUTTON_START,currentButtons,previousButtons)) {
          state = PLAY;
        }
        break;

      case PLAY:
        if (KEY_DOWN(BUTTON_UP,currentButtons) && new->row > 0) {
          new->row = (new->row)-1;    
          } else if (KEY_DOWN(BUTTON_DOWN,currentButtons) && new->row < 100) {
          new->row = (new->row)+1;    
          } else if (KEY_DOWN(BUTTON_LEFT,currentButtons) && new->col > 0) {
            new->col = (new->col)-1;
          } else if (KEY_DOWN(BUTTON_RIGHT,currentButtons) && new->col < 240-30) {
            new->col = (new->col)+1;
          }

        // collision handling with the goal object
        for (int i = goal1.row; i < goal1.row+5; i++) {
          for (int j = goal1.col; j < goal1.col+5; j++) {
            if (i >= cat1.row && i <= cat1.row+60) {
              if (j >= cat1.col && j <= cat1.col+40) {
                state = END;
              }
            }
          }
        }
        break;
      
      case END:
        break;
    }

    waitForVBlank();

    switch (state) {
      case START:
        drawFullScreenImageDMA(start);
        drawCenteredString(100,70,100,50,"Help get Cat home", WHITE);
        drawCenteredString(115,70,100,50,"Press Enter to Start!", WHITE);
        break;

      case PLAY:
        fillScreenDMA(BLACK);
        drawImageDMA(new->row, new->col, 40, 60, cat);
        drawRectDMA(newg->row, newg->col, newg->wid, newg->len, RED);

       
        char buffer[51];
        sprintf(buffer, "Time: %d", time);   
        drawString(150, 5, buffer, YELLOW);  
        temp = time;
        // drawString(150, 5, "time: ", WHITE);
        // drawChar(150, 45, time + '0', WHITE);

        break;
      
      case END:
        drawFullScreenImageDMA(lose);
        drawCenteredString(115,70,100,50,"Good job!", MAGENTA);
        sprintf(buffer, "Time Taken total: %d", temp); 
        drawCenteredString(125,70,100,50,buffer, MAGENTA);  
        //drawString(150, 5, buffer, MAGENTA); 
        break;
    }

    previousButtons = currentButtons; // Store the current state of the buttons
  }

  // UNUSED(previousButtons); // You can remove this once previousButtons is used

  return 0;
}
